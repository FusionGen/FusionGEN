{"version":3,"file":"call.js","sourceRoot":"","sources":["../../../src/less/tree/call.js"],"names":[],"mappings":"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","sourcesContent":["import Node from './node';\nimport Anonymous from './anonymous';\nimport FunctionCaller from '../functions/function-caller';\n\n//\n// A function call node.\n//\nconst Call = function(name, args, index, currentFileInfo) {\n    this.name = name;\n    this.args = args;\n    this.calc = name === 'calc';\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n}\n\nCall.prototype = new Node();\n\nCall.prototype.accept = function(visitor) {\n    if (this.args) {\n        this.args = visitor.visitArray(this.args);\n    }\n};\n\n//\n// When evaluating a function call,\n// we either find the function in the functionRegistry,\n// in which case we call it, passing the  evaluated arguments,\n// if this returns null or we cannot find the function, we\n// simply print it out as it appeared originally [2].\n//\n// The reason why we evaluate the arguments, is in the case where\n// we try to pass a variable to a function, like: `saturate(@color)`.\n// The function should receive the value, not the variable.\n//\nCall.prototype.eval = function(context) {\n    /**\n     * Turn off math for calc(), and switch back on for evaluating nested functions\n     */\n    const currentMathContext = context.mathOn;\n    context.mathOn = !this.calc;\n    if (this.calc || context.inCalc) {\n        context.enterCalc();\n    }\n\n    const exitCalc = () => {\n        if (this.calc || context.inCalc) {\n            context.exitCalc();\n        }\n        context.mathOn = currentMathContext;\n    };\n\n    let result;\n    const funcCaller = new FunctionCaller(this.name, context, this.getIndex(), this.fileInfo());\n\n    if (funcCaller.isValid()) {\n        try {\n            result = funcCaller.call(this.args);\n            exitCalc();\n        } catch (e) {\n            if (e.hasOwnProperty('line') && e.hasOwnProperty('column')) {\n                throw e\n            }\n            throw { \n                type: e.type || 'Runtime',\n                message: `error evaluating function \\`${this.name}\\`${e.message ? `: ${e.message}` : ''}`,\n                index: this.getIndex(), \n                filename: this.fileInfo().filename,\n                line: e.lineNumber,\n                column: e.columnNumber\n            };\n        }\n\n        if (result !== null && result !== undefined) {\n            // Results that that are not nodes are cast as Anonymous nodes\n            // Falsy values or booleans are returned as empty nodes\n            if (!(result instanceof Node)) {\n                if (!result || result === true) {\n                    result = new Anonymous(null); \n                }\n                else {\n                    result = new Anonymous(result.toString()); \n                }\n                \n            }\n            result._index = this._index;\n            result._fileInfo = this._fileInfo;\n            return result;\n        }\n    }\n\n    const args = this.args.map(a => a.eval(context));\n    exitCalc();\n\n    return new Call(this.name, args, this.getIndex(), this.fileInfo());\n};\n\nCall.prototype.genCSS = function(context, output) {\n    output.add(`${this.name}(`, this.fileInfo(), this.getIndex());\n\n    for (let i = 0; i < this.args.length; i++) {\n        this.args[i].genCSS(context, output);\n        if (i + 1 < this.args.length) {\n            output.add(', ');\n        }\n    }\n\n    output.add(')');\n};\n\nCall.prototype.type = 'Call';\nexport default Call;\n"]}